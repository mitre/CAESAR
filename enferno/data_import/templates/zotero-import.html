{% extends "layouts/layout.html" %}
{% block css %}
<link rel="stylesheet" href="/static/js/dropzone/vue2Dropzone.min.css" />
<link rel="stylesheet" href="/static/js/dropzone/basic.css" />
{% endblock %}
{% block content %}
<div id="app">
  <v-app v-cloak>
    {% include 'components/nav-drawer.html' %}
    {% include "components/nav-bar.html" %}
    <v-main class="align-start ma-3">
      <v-container fluid fill-height>
        <v-row>
          <v-col cols="12">
            <v-card>
                <v-card-title>
                    <span class="headline">
                        {{ _("Upload Zotero RDF Exported Files") }}
                    </span>
                </v-card-title>
                <v-card-text>
                    <v-container>
                        <v-row>
                          <p>
                            {{ _("This Zotero upload function expects that Zotero files have been exported in the RIS format. This includes a .ris manifest file and additional exported files exported into a file tree. All these files should be uploaded.") }}
                          </p>
                          <p>
                            {{ _("You can drag and drop the export folder into the dropzone - all files in the folder will be attached. You can also click the dropzone to open a file selector. If you use the file selector, you must select files within the directory individually.") }}
                          </p>
                          <p>
                            {{ _("Important!!! First, the directory path to each file added to the dropzone is preserved. Second, the .ris file is a manifest for all media files in the associated directories within the Zotero export, and the media files are identified in the manifest by their relative directory path.") }}
                          </p>
                        </v-row>
                        <v-row>
                            <v-col cols="12">
                                <!-- https://docs.dropzone.dev/configuration/basics/configuration-options -->
                                <vue-dropzone ref="dropzone" id="dropzone" class="ma-auto" :options="dzOpts"
                                  @vdropzone-sending="fileSending"
                                  @vdropzone-success="uploadSuccess"
                                  @vdropzone-
                                  @vdropzone-removed-file="fileRemoved"
                                  @vdropzone-error="uploadError"
                                  @vdropzone-file-added="fileAdded"
                                ></vue-dropzone>
                            </v-col>
                        </v-row>
                        <v-row></v-row>
                    </v-container>
                </v-card-text>
                <v-card-actions class="pa-5">
                    <v-spacer></v-spacer>
                    <v-tooltip top open-delay=1500 >
                      <template v-slot:activator="{ on }">
                        <v-btn v-on="on" @click="executeZoteroImport" color="primary">{{ _("Upload") }}</v-btn>
                      </template>
                      <span>{{ _("CAESAR interprets the Zotero exports to build Primary Records.") }}</span>
                    </v-tooltip>
                    <v-spacer></v-spacer>
                </v-card-actions>
            </v-card>
            <v-snackbar v-model="snackbar" class="">
              <div class="d-flex justify-space-between align-center">
                ${ snackMessage }
                <v-btn icon fab small color="white" text @click="snackbar = false">
                    <v-icon>mdi-close</v-icon>
                </v-btn>
              </div>
            </v-snackbar>
          </v-col>
        </v-row>
      </v-container>
    </v-main>
    {% include "components/footer.html" %}
    <v-overlay v-model="loading">
    </v-overlay>
  </v-app>
</div>
{% endblock %}
{% block js %}
<script src="/static/js/dropzone/vue2Dropzone.js"></script>
<script src="/static/js/RisParser.js"></script>
<script src="/static/js/ZoteroToCaesar.js"></script>
<script src="/static/js/ZoteroImportLogUtils.js"></script>
<script>
  const app = new Vue({
    // el, vuetify are attributes are unreferenced but necessary are part of the vue component framework
    el: "#app",
    vuetify: vuetify,
    delimiters: delimiters,
    data: () => ({
      snackbar: false,
      snackMessage: '',
      loading: false,
      status: '',
      batch_id: '',
      dzOpts: {
        autoProcessQueue: false,
        url: '/admin/api/media/chunk',
        // accept any file
        acceptedFiles: ETL_EXTENSIONS.toString(),
        addRemoveLinks: true,
        chunking: true,
        forceChunking: true,
        chunkSize: 500000, // Bytes
        thumbnailWidth: 80, // px
        thumbnailHeight: 80,
        parallelUploads: 1,
        accept: async function (file, done) {
          // Create a hash of the file
          const fileArrayBuffer = await file.arrayBuffer();
          const hash = await crypto.subtle.digest("SHA-256", fileArrayBuffer);
          const hashArray = Array.from(new Uint8Array(hash))
          var hashHex = hashArray.map((b) => b.toString(16).padStart(2, "0")).join("");
          file.etagClient = hashHex;
          done();
        }
      },
      selAllDisabled: true,
      selectedPath: '',
      recursive: false,
      // fileManifestsById is a local store of the manifest (ris, rdf, etc.) files a user has added to the dropzone
      fileManifestsById: new Map(),
      // mediaFilesById is a local store of the non-manifest Zotero-exported files a user has added to the dropzone
      mediaFilesById: new Map(),
      // etagByFileId lists the etag calculated for a file, generated on the client machine and at the server
      etagByFileId: new Map(),
      // mediaFileUploadResponseByEtag is list of returned metadata about media files that have been uploaded to CAESAR. The filepath of uploaded files is set on the server during the upload, returned, and made available via this dictionary
      mediaFileUploadResponseByEtag: new Map(),
      // zoteroItems is a list of Zotero 'item' objects read from the Zotero exported manifest file
      zoteroItems: [],
      countOfPendingMediaFileUploads: -1,
      //etl additional tags
      labels: [],
      verLabels: [],
      sources: [],
      locations: [],
      refs: [],
      roles: [],
      items: [],
      optimize: null,
      parse: null,
      ocr: null,
      selectedItems: [],
      itemsLength: 100,
      editedIndex: -1,
      editedItem: {
        title: ""
      },
      defaultItem: {
        title: "",
        active: false
      },
      medias: []
    }),
    components: {
      vueDropzone: vue2Dropzone
    },
    computed: {},
    watch: {
      items(val) {
        if (val.length) {
          this.selAllDisabled = false;
        } else {
          this.selAllDisabled = true;
        }
      },
    },
    methods: {
      // the vdropzone-sending event allows you to 'modify the request and add addtional parameters to request before sending'
      getFileExtension(filename)
      {
        return ".".concat(filename.split(".").pop().toLowerCase());
      },
      isManifestFile(file){
        return this.getFileExtension(file.name) == ".ris"
      },
      isValidMediaFile(file){
        return ETL_EXTENSIONS.includes(this.getFileExtension(file.name))
      },
      getFileFullPath(file){
        if(file.fullPath){
          return file.fullPath;
        }
        else{
          return file.name
        }
      },
      // The directory path to each file added to the dropzone is preserved as it is added. If you drag and drop a folder, the path includes each nested directory in which the file exists.
      // The Zotero manifest identifies media files with a relative directory path.
      // Depending on how files are added to the dropzone, these two values (the path of the file as seen by the dropzone and the path as listed in the Zotero manifest) can be different.
      // We need these two values to be reconciled so that the correct files are uploaded for a given manifest.
      getMediaFileIdsAssociatedWithFileLinksFromTheZoteroManifest(urlsFromManifest){
        mediaFileIdsBySimplified = new Map()
        correctedFileIds = []
        // console.error("mediafilesbyid " + JSON.stringify(Object.fromEntries(this.mediaFilesById)))
        for(i = 0; i < urlsFromManifest.length; i++){
          correctedFileIds.push(this.getMediaFileIdAssociatedWithFileLink(urlsFromManifest[i]))
        }

        return correctedFileIds
      },
      getMediaFileIdAssociatedWithFileLink(url){
        if(this.mediaFilesById.has(url)){ // there's no issue if the link listed inthe manifest is the id of an uploaded file
          return url
        }
        
        // if the file is uploaded via the file selector, it will not have a path beyond the filename
        // remediation is to update that
        filename = url.split('/').at(-1)
        if(this.mediaFilesById.has(filename)){
          return filename
        }

        // if the file is drag-dropped into the dropzone from anywhere other than the local directory of the manifest file, its path will differ from what the manifest file lists
        // this logic just fixes the common drag-the-top-level-folder scenario
        if(mediaFileIdsBySimplified.size == 0){ // lazy initialization
          mediaFileIdsBySimplified = this.getMappingFromOriginalPathToSimplifiedPath()
        }
        // console.error("mediaFileIdsBySimplified " + JSON.stringify(Object.fromEntries(mediaFileIdsBySimplified)))
        if(mediaFileIdsBySimplified.has(url)){
          return mediaFileIdsBySimplified.get(url)
        }
        
        // It is an error state to not find any variation of the URL in the list of uploaded media files.
        console.error("It appears that media file " + url + " included in the Zotero manifest (.ris file) has not been added to the dropzone.")
      },
      // See the comments on getMediaFileIdsAssociatedWithFileLinksFromTheZoteroManifest
      getMappingFromOriginalPathToSimplifiedPath()
      {
        mediaFileIdsBySimplified = new Map()
        for(fileId of this.mediaFilesById.keys()){
          splitPath = fileId.split('/')
          if(splitPath[0] != 'files' && splitPath[1] == 'files'){
            splitPath.shift()
            simplifiedPath = splitPath.join('/')
            mediaFileIdsBySimplified.set(simplifiedPath, fileId)
          }
        }
        return mediaFileIdsBySimplified
      },
      fileSending(file, xhr, formData) {
        if(file.fullPath){
            formData.append("fullPath", file.fullPath);
        }
        formData.set("etagClient", file.etagClient);
      },
      save_log(import_log){
        axios.post("/import/api/import-log", {
          item: import_log
        }).then(response => {
        }).catch(err => {
          console.error("error saving log " + err)
          this.showSnack(err.response.data);
        })
      },
      // the vdropzone-success event allows you to respond to the server response after a file has been uploaded successfully
      uploadSuccess(dzfile) {
        // pick file from dropzone files list
        needle = this.$refs.dropzone.getAcceptedFiles().filter(x => x.status === 'success').filter(x => parseResponse(x).uuid === dzfile.upload.uuid).pop();
        file = parseResponse(needle);
        this.mediaFileUploadResponseByEtag.set(file["etag"], file)
        this.countOfPendingMediaFileUploads = this.countOfPendingMediaFileUploads - 1;

        if(this.countOfPendingMediaFileUploads < 0){
          console.error("This is unexpected error condition.");
        }

        file_extension = this.getFileExtension(file["filename"])
        import_log = getMediaImportLog(0, file["filename"], file_extension, file["etag"], this.batch_id, getImportStatusFromStatusCode(200), "", "")
        this.save_log(import_log)

        if(this.countOfPendingMediaFileUploads == 0){
          this.buildCaesarObjectsAfterMediaUploadsComplete(this.batch_id);
        }
      },
      // vdropzone-removed-file fires after a file has been removed from the dropzone
      fileAdded(file) {
        file_id=this.getFileFullPath(file)
        if(this.isManifestFile(file)){
          this.fileManifestsById.set(file_id, file)
          // console.error("fileManifestsById " + JSON.stringify(Object.fromEntries(this.fileManifestsById)))
        }
        // MEDIA_ALLOWED_EXTENSIONS is a config object that lives in flask, python-side.  ETL_EXTENSIONS is a duplicate config object defined in code, js-side? 
        else if(this.isValidMediaFile(file)){
          this.mediaFilesById.set(file_id, file)
          // console.error("mediafilesbyid " + JSON.stringify(Object.fromEntries(this.mediaFilesById)))
        }
        else{
          console.error("File with invalid extension selected for upload.")
        }
      },
      fileRemoved(file, error, xhr) {
        if (error) {
          console.error(error)
        }

        file_id=this.getFileFullPath(file)
        if(this.isManifestFile(file)){
          this.fileManifestsById.delete(file_id)
          // console.error("fileManifestsById " + JSON.stringify(Object.fromEntries(this.fileManifestsById)))
        }
        else if(this.isValidMediaFile(file)){
          this.mediaFilesById.delete(file_id)
          // console.error("mediafilesbyid " + JSON.stringify(Object.fromEntries(this.mediaFilesById)))
        }
      },
      // vdropzone-error is fired when an error occurs. Receives the error message as second parameter and if the error was due to the XMLHttpRequest the xhr object as third.
      showSnack(message) {
        console.log("SNACK: " + this.snackMessage)
        this.snackbar = true
        this.snackMessage = message
      },
      uploadError(err, message) {
        try{
          // console.error("errorlog " + JSON.stringify(err))
          // console.error("message " + JSON.stringify(message))
          import_log = getMediaImportLog(0, "fileId", "file_extension", "etag", this.batch_id, getImportStatusFromStatusCode(500), "", "err + message")
          // console.error("import log " + JSON.stringify(import_log))
          this.save_log(import_log)
          console.error(err)
          console.error(message)
          this.showSnack(message)
        }
        catch(error){
          console.error("error!: " + error)
        }
      },
      executeZoteroImport(){
        if(this.fileManifestsById.size == 0){
          console.error('No manifest file attached.')
        }
        this.batch_id = crypto.randomUUID()

        for(manifest of this.fileManifestsById.values()){
          parseRisFile(manifest, this.processFileManifestCallback)
        }
      },
      // this method is called after filereader asynchronously opens/reads the manifest file
      processFileManifestCallback(zoteroItems){
        this.zoteroItems = zoteroItems
        urlsListedInTheZoteroManifest = getMediaFilesListedInTheZoteroManifest(zoteroItems)
        mediaFileIds = this.getMediaFileIdsAssociatedWithFileLinksFromTheZoteroManifest(urlsListedInTheZoteroManifest)

        // we're going to wait for all of these uploads to complete to build CAESAR objects
        this.countOfPendingMediaFileUploads = mediaFileIds.length;

        for(i = 0; i <mediaFileIds.length; i++){
          fileId = mediaFileIds[i]
          if(this.mediaFilesById.has(fileId)){
            file = this.mediaFilesById.get(fileId)
            etag = file["etagClient"]
            this.etagByFileId.set(fileId, etag)
            result = this.$refs.dropzone.dropzone.processFile(file)
          }
          else{
            console.error("Media file " + fileId + " was expected for upload but was not added to the dropzone.")
          }
        }
      },
      // once the files have been uploaded, we can look up the media path by an etag - but we need to wait for media uploads to complete to do this
      buildCaesarObjectsAfterMediaUploadsComplete(batch_id){
        for(i=0; i<this.zoteroItems.length; i++){
          item = this.zoteroItems[i]
          mediaFilePath = ""
          try{
            fileId = this.getMediaFileIdAssociatedWithFileLink(getMediaFileFromZoteroItem(item))
            // console.error("etagByFileId " + JSON.stringify([...this.etagByFileId.entries()]))
            etag = this.etagByFileId.get(fileId)
            fileUploadInfo = this.mediaFileUploadResponseByEtag.get(etag)
            mediaFilePath = fileUploadInfo["s3url"]
          }
          catch(error){
            console.error("Error when trying to find uploaded file.")
          }
          bulletin = getBulletinFromZoteroItem(item, mediaFilePath)

          // post bulletin
          axios.post("/admin/api/bulletin/", {
                item: bulletin
            }).then(response => {
                this.showSnack(response.data);
                bulletin_id = response.data.substring(18)
                file_extension = this.getFileExtension(this.mediaFilesById.get(fileId).name)
                import_log = getBulletinImportLog(bulletin_id, fileId, file_extension, etag, batch_id, getImportStatusFromStatusCode(response.status), "", "")
                this.save_log(import_log)
            }).catch(err => {
                this.showSnack(err.response.data);
            }).then(() => {
          });
        }
        this.batch_id = ''
      }
    }
  });
</script>
{% endblock %}